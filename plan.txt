I will now create a detailed plan for a Python-based Pterodactyl "remake" managed through a Discord bot. This plan will be saved in a file named `plan.txt` and will cover the core concepts, SFTP management, Docker integration, and an explanation of the Egg system, all organized to be highly detailed and easy to understand.

Here is the content I will write to the file:

```
Pterodactyl Re-imagined: A Discord-Managed Hosting Platform

## Introduction

**Goal:** To create a lightweight, powerful, and user-friendly server management platform where all operations are handled through a Discord bot. This project re-imagines the Pterodactyl panel's core functionalities, replacing the web interface with Discord commands and interactions.

**Core Components:**
*   **Discord Bot (The "Panel"):** The primary user interface for all server management tasks.
*   **Python Backend (The "Daemon"):** The worker service that runs on host machines, executing commands received from the bot.
*   **Docker:** The containerization engine used to run and isolate each game server instance.
*   **SFTP Service:** Provides users with secure file access to their server directories.

---

## Section 1: System Architecture

### The Discord Bot (The "Panel")
This bot, built with a library like `discord.py`, is the command and control center for users.

**Responsibilities:**
*   **User Interaction:** Provides a command-based interface (e.g., `/server create`, `/server stop`) using Discord's slash command functionality.
*   **UI Elements:** Uses interactive components like buttons, dropdowns (select menus), and modals to guide users through complex processes like server creation and configuration.
*   **Status Display:** Shows real-time server status, IP addresses, and resource usage (CPU, RAM, Disk) in dedicated channels or through status commands.
*   **Permission Handling:** Manages user access to servers based on their Discord roles. A "Server Owner" role could have full control, while a "Moderator" role might only have start/stop permissions.
*   **API Communication:** Communicates with the Python Backend. This is done securely via a REST API, where the bot sends authenticated requests to the backend to perform actions.

### The Python Backend (The "Daemon")
This is the workhorse of the system, a Python application running on each physical server (Node) that will host game servers.

**Responsibilities:**
*   **API Server:** Listens for incoming HTTP requests from the Discord Bot.
*   **Docker Integration:** Directly interacts with the Docker API (using the `docker-py` library) to manage the entire lifecycle of server containers (create, start, stop, delete, inspect).
*   **Server Lifecycle Management:** Handles the installation process (using the Egg's install script), manages server startup, and monitors for crashes.
*   **Resource Monitoring:** Continuously tracks the CPU, memory, and disk usage of each container and provides this data back to the bot when requested.
*   **Egg Processing:** Reads and interprets "Egg" files to correctly configure and launch new server instances.
*   **SFTP & User Management:** Manages the creation and permissions of SFTP users, ensuring they are sandboxed to their specific server's directory.

---

## Section 2: Docker Containerization Explained

**Concept:** Every game server (e.g., Minecraft, Valheim, etc.) runs inside its own isolated Docker container. This is the fundamental principle that ensures security and stability.

**Benefits:**
*   **Security & Isolation:** A process in one container cannot interfere with other containers or the host system. If one server crashes, it doesn't affect any others.
*   **Resource Control:** Each container can be strictly limited in the amount of CPU and RAM it can use, preventing a single server from consuming all of the host's resources.
*   **Dependency Management:** All of a server's required software (like a specific Java version) is packaged within its Docker image, eliminating conflicts on the host machine.
*   **Consistency:** A server runs identically regardless of the underlying host machine's configuration.

**Process Flow:**
1.  A user initiates a `/server create` command from Discord.
2.  The bot sends the validated request to the backend.
3.  The backend selects an "Egg" based on the user's choice.
4.  It pulls the Docker image specified in the Egg (e.g., `itzg/minecraft-server`).
5.  It creates a new Docker container from this image, applying the resource limits (CPU/RAM) and port mappings defined in the Egg and by the user.
6.  The backend executes the startup command from the Egg inside the new container, which starts the game server.

---

## Section 3: SFTP (Secure File Transfer Protocol) Management

**Concept:** To give users direct file access, the system will manage a sandboxed SFTP service for each server.

**Pterodactyl's Approach:** The Pterodactyl Daemon includes a built-in SFTP server that brokers connections and authenticates users against the panel's database.

**Our Re-imagined Approach:**
1.  **SFTP Service:** The Python backend will be responsible for managing SFTP access. When a server is created, a corresponding SFTP user account is also provisioned.
2.  **Sandboxing:** This SFTP user is "chrooted" or sandboxed, meaning they can only see and edit files within their assigned server's directory (e.g., `/var/lib/pterodactyl/volumes/<server-uuid>`). They cannot navigate outside of this folder.
3.  **Generating Credentials:**
    *   The Discord bot will feature a `/sftp credentials` command.
    *   When a user runs this command for a server they own, the bot requests new credentials from the backend.
    *   The backend generates a unique username (e.g., `user.1a2b3c`) and a strong, random password.
    *   For security, the bot sends these credentials directly to the user in a private DM (Direct Message). The credentials will point to the host machine's IP and a specific port used for SFTP.

---

## Section 4: The "Egg" System Explained

**What is an Egg?** An Egg is a JSON or YAML file that acts as a blueprint for a specific type of game server. It tells the backend everything it needs to know to install, configure, and run that server. A "Nest" is simply a logical grouping of Eggs (e.g., the "Minecraft" Nest contains Eggs for Vanilla, Paper, Forge, etc.).

**Key Components of an Egg:**
*   **`name`, `description`:** Human-readable identifiers.
*   **`docker_image`:** The exact Docker image to use for the server (e.g., `ghcr.io/pterodactyl/yolks:java_17`).
*   **`startup`:** The command-line instruction to start the server application inside the container. It uses variables that will be replaced at runtime (e.g., `java -Xms128M -Xmx{{SERVER_MEMORY}}M -jar server.jar`).
*   **`environment`:** A dictionary of environment variables to be passed to the container. These are the user-configurable settings, such as:
    *   `SERVER_JARFILE` (e.g., `server.jar`)
    *   `MINECRAFT_VERSION` (e.g., `latest`)
    *   `SERVER_PORT` (variable, e.g., `{{SERVER_PORT}}`)
*   **`install_script` (optional):** A shell script that is executed in a temporary container during the installation phase. It's used to download necessary files, like a specific version of a game server JAR.
*   **`ports`:** Defines the default ports the container needs and how they should be mapped to the host.
*   **`resources`:** Defines the CPU, memory, and disk space requirements.

**Our Implementation:**
The backend will have a folder containing all the Egg definition files. When a user selects "Paper Minecraft" in the Discord bot, the backend loads the `paper.json` Egg, reads its contents, and uses that data to orchestrate the entire server creation process with Docker.

---

## Section 5: Example Workflow - Creating a New Server

1.  **User:** Executes the `/server create` command in a designated Discord channel.
2.  **Bot:** Responds with a dropdown menu to select a "Nest" (e.g., Minecraft, Terraria, Valheim).
3.  **User:** Selects "Minecraft".
4.  **Bot:** Updates the message with a new dropdown to select an "Egg" (e.g., Paper, Forge, Vanilla).
5.  **User:** Selects "Paper".
6.  **Bot:** Pops up a modal (form) asking for required inputs: `Server Name`, `Memory (MB)`.
7.  **User:** Fills out the form and clicks "Submit".
8.  **Bot:** Sends a secure API call to the Python backend: `POST /api/servers` with all the collected data (`egg_id`, `user_id`, `config_options`).
9.  **Backend:**
    *   Validates the request.
    *   Loads the `paper.json` Egg.
    *   If it's a first-time install, runs the Egg's `install_script`.
    *   Instructs Docker to create a new container using the `docker_image`, `startup` command, `environment` variables, and port mappings from the Egg.
    *   Starts the newly created container.
10. **Backend:** Monitors the container's logs for a "server started successfully" message.
11. **Backend:** Responds to the bot with a success message, including the server's IP and port.
12. **Bot:** Edits its original message to show "Server is now online!" and displays the connection info to the user.
```